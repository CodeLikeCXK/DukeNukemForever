postprocess_upscale
{
	vertex
	{
		gl_Position = TransformVertex($mvpMatrixX, $mvpMatrixY, $mvpMatrixZ, $mvpMatrixW);
		vertex_texcoord0 = attr_TexCoord0;
	}

	pixel
	{
		vec2 texcoord = vertex_texcoord0.xy;
        float Sharpness = 0.8;

        // fetch a 3x3 neighborhood around the pixel 'e',
        //  a b c
        //  d(e)f
        //  g h i
        //  int2 bufferSize = textureSize2D(diffuseImage);
        float pixelX = 1.0 / $screeninfo.x;
        float pixelY = 1.0 / $screeninfo.y;
   
        vec3 a = texture2D($albedotexture, texcoord + vec2(-pixelX, -pixelY)).rgb;
        vec3 b = texture2D($albedotexture, texcoord + vec2(0.0, -pixelY)).rgb;
        vec3 c = texture2D($albedotexture, texcoord + vec2(pixelX, -pixelY)).rgb;
        vec3 d = texture2D($albedotexture, texcoord + vec2(-pixelX, 0.0)).rgb;
        vec3 e = texture2D($albedotexture, texcoord).rgb;
        vec3 f = texture2D($albedotexture, texcoord + vec2(pixelX, 0.0)).rgb;
        vec3 g = texture2D($albedotexture, texcoord + vec2(-pixelX, pixelY)).rgb;
        vec3 h = texture2D($albedotexture, texcoord + vec2(0.0, pixelY)).rgb;
        vec3 i = texture2D($albedotexture, texcoord + vec2(pixelX, pixelY)).rgb;
 
        // Soft min and max.
	    //  a b c             b
	    //  d e f * 0.5  +  d e f * 0.5
	    //  g h i             h
        // These are 2.0x bigger (factored out the extra multiply).
        float mnR = Min3( Min3(d.r, e.r, f.r), b.r, h.r);
        float mnG = Min3( Min3(d.g, e.g, f.g), b.g, h.g);
        float mnB = Min3( Min3(d.b, e.b, f.b), b.b, h.b);
        
        float mnR2 = Min3( Min3(mnR, a.r, c.r), g.r, i.r);
        float mnG2 = Min3( Min3(mnG, a.g, c.g), g.g, i.g);
        float mnB2 = Min3( Min3(mnB, a.b, c.b), g.b, i.b);
        mnR = mnR + mnR2;
        mnG = mnG + mnG2;
        mnB = mnB + mnB2;
        
        float mxR = Max3( Max3(d.r, e.r, f.r), b.r, h.r);
        float mxG = Max3( Max3(d.g, e.g, f.g), b.g, h.g);
        float mxB = Max3( Max3(d.b, e.b, f.b), b.b, h.b);
        
        float mxR2 = Max3( Max3(mxR, a.r, c.r), g.r, i.r);
        float mxG2 = Max3( Max3(mxG, a.g, c.g), g.g, i.g);
        float mxB2 = Max3( Max3(mxB, a.b, c.b), g.b, i.b);
        mxR = mxR + mxR2;
        mxG = mxG + mxG2;
        mxB = mxB + mxB2;
        
        // Smooth minimum distance to signal limit divided by smooth max.
        float rcpMR = rcp(mxR);
        float rcpMG = rcp(mxG);
        float rcpMB = rcp(mxB);

        float ampR = saturate(min(mnR, 2.0 - mxR) * rcpMR);
        float ampG = saturate(min(mnG, 2.0 - mxG) * rcpMG);
        float ampB = saturate(min(mnB, 2.0 - mxB) * rcpMB);
        
        // Shaping amount of sharpening.
        ampR = sqrt(ampR);
        ampG = sqrt(ampG);
        ampB = sqrt(ampB);
    
        // Filter shape.
        //  0 w 0
        //  w 1 w
        //  0 w 0  
        float peak = -rcp(mix(8.0, 5.0, saturate(Sharpness)));
        
        float wR = ampR * peak;
        float wG = ampG * peak;
        float wB = ampB * peak;
        
        float rcpWeightR = rcp(1.0 + 4.0 * wR);
        float rcpWeightG = rcp(1.0 + 4.0 * wG);
        float rcpWeightB = rcp(1.0 + 4.0 * wB);
   
   		vec3 outColor = vec3(saturate((b.r*wR+d.r*wR+f.r*wR+h.r*wR+e.r)*rcpWeightR),
                            saturate((b.g*wG+d.g*wG+f.g*wG+h.g*wG+e.g)*rcpWeightG),
                            saturate((b.b*wB+d.b*wB+f.b*wB+h.b*wB+e.b)*rcpWeightB));

		finalpixel_color.xyz = outColor;
        finalpixel_color.w = 1;
	}
}