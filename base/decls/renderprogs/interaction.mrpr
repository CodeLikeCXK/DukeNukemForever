renderProg interaction
{
	vertex
	{
		vec3 vNormal = attr_Normal.xyz;
		vec3 vTangent = attr_Tangent.xyz;
		vec3 vBinormal = attr_Bitangent.xyz;
		
		gl_Position = TransformVertex($mvpMatrixX, $mvpMatrixY, $mvpMatrixZ, $mvpMatrixW);
			
		vec4 defaultTexCoord = vec4( 0.0f, 0.5f, 0.0f, 1.0f );

		//# textures 4 takes the base coordinates by the texture matrix
		vertex_texcoord4 = defaultTexCoord;
		vertex_texcoord4.x = dot4( attr_TexCoord0.xy, $rpdiffusematrixs );
		vertex_texcoord4.y = dot4( attr_TexCoord0.xy, $rpdiffusematrixt );

		//# textures 5 takes the base coordinates by the texture matrix
		vertex_texcoord5.x = dot4( attr_Position, $modelMatrixX );
		vertex_texcoord5.y = dot4( attr_Position, $modelMatrixY );
		vertex_texcoord5.z = dot4( attr_Position, $modelMatrixZ );
		vertex_texcoord5.w = dot4( attr_Position, $modelMatrixW );		

		vertex_texcoord0.xyz = vTangent.xyz;
		vertex_texcoord0.w = 0;

		vertex_texcoord1.xyz = vBinormal.xyz;
		vertex_texcoord1.w = 0;

		vertex_texcoord3.xyz = vNormal.xyz;
		vertex_texcoord3.w = 0;

	}

	pixel
	{
		vec3 vTangent = vertex_texcoord0.xyz;
		vec3 vBinormal = vertex_texcoord1.xyz;
		vec3 vNormal = vertex_texcoord3.xyz;

		vec4 vertex = vertex_texcoord5;

		vec3 finalColor = vec3(0, 0, 0);

		vec4 diffuseMap =			tex2D( $albedotexture, vertex_texcoord4.xy );
		//# calculate normalized vector to viewer in R1
		vec4 toView = normalize( $vieworigin - vertex );
		
		vec2 st = vertex_texcoord4.xy;
		vec3 viewTangentVector;

		viewTangentVector.x = dot3( vTangent, toView );
		viewTangentVector.y = dot3( vBinormal, toView );
		viewTangentVector.z = dot3( vNormal, toView );

		vec4 bumpMap =			tex2D( $bumpmap, st );			
		vec4 specMap =			tex2D( $specularmap, st );

		vec3 localNormal;
		localNormal.xy = bumpMap.wy - 0.5;
		localNormal.z = sqrt( abs( dot( localNormal.xy, localNormal.xy ) - 0.25 ) );
		localNormal = normalize( localNormal );

		if(diffuseMap.w == 0)
			discard;

		for(int i = 0; i < $numLights; i++)
		{
			vec3 lc = $lightcolor[i].xyz;

			vec4 toLight = $globalLightOrigin[i] - vertex;	

			//# add together to become the half angle vector in object space (non-normalized)
			vec4 halfAngleVector = toLight + toView;
			vec3 halfAngleTangentVector;
			halfAngleTangentVector.x = dot3( vTangent.xyz, halfAngleVector );
			halfAngleTangentVector.y = dot3( vBinormal, halfAngleVector );
			halfAngleTangentVector.z = dot3( vNormal, halfAngleVector );
			
			vec3 lightTangentVector;
			lightTangentVector.x = dot3( vTangent, toLight );
			lightTangentVector.y = dot3( vBinormal, toLight );
			lightTangentVector.z = dot3( vNormal, toLight );	

			vec3 lightVector = normalize( lightTangentVector.xyz );	

			const float specularPower = 10.0f;
			float hDotN = dot3( normalize( halfAngleTangentVector ), localNormal );

			// vec3 CalcSpecPBR(vec3 cameraVector, vec4 Cd, vec4 metallic, float roughness, vec3 H, vec3 N, vec3 L)
			vec3 pbr = CalcSpecPBR(viewTangentVector.xyz, 
							diffuseMap.xyz, 
							0.5, 
							0.5, 
							normalize(halfAngleTangentVector), localNormal, lightVector);

			float attenuation = AttenuationPointLight(vertex_texcoord5.xyz, vec4($globalLightOrigin[i].xyz, 1.0), $globalLightExtents[i]);
			float lit = dot3( localNormal, lightVector ) * attenuation;

			if(lit <= 0)
				continue;

			float shadow = 1.0f; 
			vec4 _shadowMapInfo = $shadowMapInfo[i];

			pbr = pbr * 1.5;

			if(_shadowMapInfo.w == 1)
			{
				shadow = CalculateShadows($atlasLookup, $shadowMapAtlas, vertex_texcoord5.xyz, $globalLightOrigin[i].xyz, _shadowMapInfo);
			}
#ifdef SPEC_ONLY_TEST
			finalColor += (lc * ((pbr  * shadow * attenuation))) ;
#else
			finalColor += (lc * ((lit  * shadow) + (pbr  * shadow * attenuation))) ;
#endif
		}

#ifdef SPEC_ONLY_TEST
		finalpixel_color.xyz = finalColor;
#else
		finalpixel_color.xyz = diffuseMap.xyz * ((finalColor * 3.0) + 0.3);
#endif
		finalpixel_color.w = diffuseMap.w;

		finalpixel_color2.xyz = vertex_texcoord3.xyz;
		finalpixel_color2.w = diffuseMap.w;

		finalpixel_color3.xyz = vertex.xyz;
		finalpixel_color3.w = diffuseMap.w;
	}
}