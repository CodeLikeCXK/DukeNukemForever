renderProg interaction
{
	vertex
	{
		vec3 vNormal = attr_Normal.xyz;
		vec3 vTangent = attr_Tangent.xyz;
		vec3 vBinormal = attr_Bitangent.xyz;
		
		gl_Position = TransformVertex($mvpMatrixX, $mvpMatrixY, $mvpMatrixZ, $mvpMatrixW);
			
		vec4 defaultTexCoord = vec4( 0.0f, 0.5f, 0.0f, 1.0f );

		//# textures 4 takes the base coordinates by the texture matrix
		vertex_texcoord4 = defaultTexCoord;
		vertex_texcoord4.x = dot4( attr_TexCoord0.xy, $rpdiffusematrixs );
		vertex_texcoord4.y = dot4( attr_TexCoord0.xy, $rpdiffusematrixt );

		//# textures 5 takes the base coordinates by the texture matrix
		vertex_texcoord5.x = dot4( attr_Position, $modelMatrixX );
		vertex_texcoord5.y = dot4( attr_Position, $modelMatrixY );
		vertex_texcoord5.z = dot4( attr_Position, $modelMatrixZ );
		vertex_texcoord5.w = dot4( attr_Position, $modelMatrixW );		

		vertex_texcoord0.xyz = vTangent.xyz;
		vertex_texcoord0.w = 0;

		vertex_texcoord1.xyz = vBinormal.xyz;
		vertex_texcoord1.w = 0;

		vertex_texcoord3.xyz = vNormal.xyz;
		vertex_texcoord3.w = 0;

	}

	pixel
	{
		vec3 vTangent = vertex_texcoord0.xyz;
		vec3 vBinormal = vertex_texcoord1.xyz;
		vec3 vNormal = vertex_texcoord3.xyz;

		vec4 vertex = vertex_texcoord5;

		vec3 finalColor = vec3(0, 0, 0);

		vec4 diffuseMap =			tex2D( $albedotexture, vertex_texcoord4.xy );

		if(diffuseMap.w == 0)
			discard;

		for(int i = 0; i < $numLights; i++)
		{
			vec3 lc = $lightcolor[i].xyz;

			vec4 toLight = $globalLightOrigin[i] - vertex;

			//# calculate normalized vector to viewer in R1
			vec4 toView = normalize( $vieworigin - vertex );
		
			//# add together to become the half angle vector in object space (non-normalized)
			vec4 halfAngleVector = toLight + toView;

			vec2 st = vertex_texcoord4.xy;

			vec3 lightTangentVector;
			vec3 halfAngleTangentVector;

			lightTangentVector.x = dot3( vTangent, toLight );
			lightTangentVector.y = dot3( vBinormal, toLight );
			lightTangentVector.z = dot3( vNormal, toLight );
		
			halfAngleTangentVector.x = dot3( vTangent.xyz, halfAngleVector );
			halfAngleTangentVector.y = dot3( vBinormal, halfAngleVector );
			halfAngleTangentVector.z = dot3( vNormal, halfAngleVector );

			vec4 bumpMap =			tex2D( $bumpmap, st );			
			vec4 specMap =			tex2D( $specularmap, st );

			vec3 lightVector = normalize( lightTangentVector.xyz );

			vec3 localNormal;
			localNormal.xy = bumpMap.wy - 0.5;
			localNormal.z = sqrt( abs( dot( localNormal.xy, localNormal.xy ) - 0.25 ) );
			localNormal = normalize( localNormal );

			const float specularPower = 10.0f;
			float hDotN = dot3( normalize( halfAngleTangentVector ), localNormal );
			vec3 specularContribution = vec3( pow(hDotN, specularPower) );

			vec3 specularColor = localNormal.x * specularContribution;

			float attenuation = AttenuationPointLight(vertex_texcoord5.xyz, vec4($globalLightOrigin[i].xyz, 1.0), $globalLightExtents[i]);
			float lit = dot3( localNormal, lightVector ) * attenuation;

			if(lit <= 0)
				continue;

			float shadow = 1.0f; 
			vec4 _shadowMapInfo = $shadowMapInfo[i];

			if(_shadowMapInfo.w == 1)
			{
				shadow = CalculateShadows($atlasLookup, $shadowMapAtlas, vertex_texcoord5.xyz, $globalLightOrigin[i].xyz, _shadowMapInfo);
			}

			finalColor += ((lc * lit) + (lc * specularColor))  * shadow;
		}

		finalpixel_color.xyz = diffuseMap.xyz * ((finalColor * 2.0) + 0.1);
		finalpixel_color.w = diffuseMap.w;
	}
}