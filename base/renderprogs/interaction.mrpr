renderProg interaction
{
	vertex
	{
		vec3 vNormal = attr_Normal.xyz;
		vec3 vTangent = attr_Tangent.xyz;
		vec3 vBinormal = attr_Bitangent.xyz;
		
		gl_Position = ftransform();
			
		vec4 defaultTexCoord = vec4( 0.0f, 0.5f, 0.0f, 1.0f );

		//# textures 4 takes the base coordinates by the texture matrix
		gl_TexCoord[4] = defaultTexCoord;
		gl_TexCoord[4].x = dot4( attr_TexCoord0.xy, $rpdiffusematrixs );
		gl_TexCoord[4].y = dot4( attr_TexCoord0.xy, $rpdiffusematrixt );

		//# textures 5 takes the base coordinates by the texture matrix
		gl_TexCoord[5].x = dot4( gl_Vertex, $modelMatrixX );
		gl_TexCoord[5].y = dot4( gl_Vertex, $modelMatrixY );
		gl_TexCoord[5].z = dot4( gl_Vertex, $modelMatrixZ );
		gl_TexCoord[5].w = dot4( gl_Vertex, $modelMatrixW );		

		gl_TexCoord[0].xyz = vTangent.xyz;
		gl_TexCoord[0].w = 0;

		gl_TexCoord[1].xyz = vBinormal.xyz;
		gl_TexCoord[1].w = 0;

		gl_TexCoord[3].xyz = vNormal.xyz;
		gl_TexCoord[3].w = 0;

	}

	pixel
	{
		vec3 vTangent = gl_TexCoord[0].xyz;
		vec3 vBinormal = gl_TexCoord[1].xyz;
		vec3 vNormal = gl_TexCoord[3].xyz;

		vec4 vertex = gl_TexCoord[5];

		vec3 finalColor = vec3(0, 0, 0);

		vec4 diffuseMap =			tex2D( $albedotexture, gl_TexCoord[4].xy );

		if(diffuseMap.w == 0)
			discard;

		for(int i = 0; i < $numLights; i++)
		{
			vec3 lc = $lightcolor[i].xyz;

			vec4 toLight = $globalLightOrigin[i] - vertex;

			//# calculate normalized vector to viewer in R1
			vec4 toView = normalize( $vieworigin - vertex );
		
			//# add together to become the half angle vector in object space (non-normalized)
			vec4 halfAngleVector = toLight + toView;

			vec2 st = gl_TexCoord[4].xy;

			vec3 lightTangentVector;
			vec3 halfAngleTangentVector;

			lightTangentVector.x = dot3( vTangent, toLight );
			lightTangentVector.y = dot3( vBinormal, toLight );
			lightTangentVector.z = dot3( vNormal, toLight );
		
			halfAngleTangentVector.x = dot3( vTangent.xyz, halfAngleVector );
			halfAngleTangentVector.y = dot3( vBinormal, halfAngleVector );
			halfAngleTangentVector.z = dot3( vNormal, halfAngleVector );

			vec4 bumpMap =			tex2D( $bumpmap, st );			
			vec4 specMap =			tex2D( $specularmap, st );

			vec3 lightVector = normalize( lightTangentVector.xyz );

			vec3 localNormal;
			localNormal.xy = bumpMap.wy - 0.5;
			localNormal.z = sqrt( abs( dot( localNormal.xy, localNormal.xy ) - 0.25 ) );
			localNormal = normalize( localNormal );

			const float specularPower = 10.0f;
			float hDotN = dot3( normalize( halfAngleTangentVector ), localNormal );
			vec3 specularContribution = vec3( pow(hDotN, specularPower) );

			vec3 specularColor = localNormal.x * specularContribution;

			float attenuation = AttenuationPointLight(gl_TexCoord[5].xyz, vec4($globalLightOrigin[i].xyz, 1.0), $globalLightExtents[i]);
			float lit = dot3( localNormal, lightVector ) * attenuation;

			if(lit <= 0)
				continue;

			float shadow = 1.0f; 
			vec4 _shadowMapInfo = $shadowMapInfo[i];

			if(_shadowMapInfo.w == 1)
			{
				shadow = CalculateShadows($atlasLookup, $shadowMapAtlas, gl_TexCoord[5].xyz, $globalLightOrigin[i].xyz, _shadowMapInfo);
			}

			finalColor += ((lc * lit) + (lc * specularColor))  * shadow;
		}

		gl_FragColor.xyz = diffuseMap.xyz * (finalColor + 0.1);
		gl_FragColor.w = diffuseMap.w;
	}
}