renderProg interaction
{
	vertex
	{
		vec3 vNormal = attr_Normal.xyz;
		vec3 vTangent = attr_Tangent.xyz;
		vec3 vBinormal = attr_Bitangent.xyz;
		
		gl_Position = ftransform();
			
		vec4 defaultTexCoord = vec4( 0.0f, 0.5f, 0.0f, 1.0f );
		
		gl_TexCoord[2].x = gl_Vertex.x;
		gl_TexCoord[2].y = gl_Vertex.y;
		gl_TexCoord[2].z = gl_Vertex.z;
		gl_TexCoord[2].w = 0;
		

		//# textures 4 takes the base coordinates by the texture matrix
		gl_TexCoord[4] = defaultTexCoord;
		gl_TexCoord[4].x = dot4( attr_TexCoord0.xy, $rpdiffusematrixs );
		gl_TexCoord[4].y = dot4( attr_TexCoord0.xy, $rpdiffusematrixt );

		//# textures 5 takes the base coordinates by the texture matrix
		gl_TexCoord[5].x = dot4( gl_Vertex, $modelMatrixX );
		gl_TexCoord[5].y = dot4( gl_Vertex, $modelMatrixY );
		gl_TexCoord[5].z = dot4( gl_Vertex, $modelMatrixZ );
		gl_TexCoord[5].w = dot4( gl_Vertex, $modelMatrixW );		

		gl_TexCoord[0].xyz = vTangent.xyz;
		gl_TexCoord[0].w = dot4( attr_TexCoord0.xy, $rpbumpmatrixs );

		gl_TexCoord[1].xyz = vBinormal.xyz;
		gl_TexCoord[1].w = 0;

		gl_TexCoord[3].xyz = vNormal.xyz;
		gl_TexCoord[3].w = dot4( attr_TexCoord0.xy, $rpbumpmatrixt );

	}

	pixel
	{
		vec3 vTangent = gl_TexCoord[0].xyz;
		vec3 vBinormal = gl_TexCoord[1].xyz;
		vec3 vNormal = gl_TexCoord[3].xyz;

		vec4 vertex = gl_TexCoord[2];

		vec3 finalColor = vec3(0, 0, 0);

		vec4 diffuseMap =			tex2D( $albedotexture, gl_TexCoord[4].xy );

		for(int i = 0; i < $numLights; i++)
		{
			vec4 toLight = $lightorigin[i] - vertex;

			//# calculate normalized vector to light in R0
			toLight = normalize( toLight );

			//# calculate normalized vector to viewer in R1
			vec4 toView = normalize( $vieworigin - vertex );
		
			//# add together to become the half angle vector in object space (non-normalized)
			vec4 halfAngleVector = toLight + toView;

			vec2 st = vec2(gl_TexCoord[0].w, gl_TexCoord[3].w);

			vec3 lightTangentVector;
			vec3 halfAngleTangentVector;

			lightTangentVector.x = dot3( vTangent, toLight );
			lightTangentVector.y = dot3( vBinormal, toLight );
			lightTangentVector.z = dot3( vNormal, toLight );
		
			halfAngleTangentVector.x = dot3( vTangent.xyz, halfAngleVector );
			halfAngleTangentVector.y = dot3( vBinormal, halfAngleVector );
			halfAngleTangentVector.z = dot3( vNormal, halfAngleVector );

			vec4 bumpMap =			tex2D( $bumpmap, st );			
			vec4 specMap =			tex2D( $specularmap, gl_TexCoord[4].xy );

			vec3 realLightOrigin = $globalLightOrigin[i].xyz;

			vec3 lightVector = normalize( lightTangentVector.xyz );

			vec3 localNormal = vec3(bumpMap.r, bumpMap.g, bumpMap.b);
			localNormal = localNormal * 2.0 - 1.0;

			const float specularPower = 10.0f;
			float hDotN = dot3( normalize( halfAngleTangentVector ), localNormal );
			vec3 specularContribution = vec3( pow(hDotN, specularPower) );

			vec3 diffuseColor = $lightcolor[i].xyz;
			vec3 specularColor = specMap.xyz * specularContribution;

			float attenuation = AttenuationPointLight(gl_TexCoord[5].xyz, vec4(realLightOrigin, 1.0), $globalLightExtents[i]);
			float lightColor = dot3( localNormal, lightVector ) * attenuation;

			float shadow = CalculateShadows($atlasLookup, $shadowMapAtlas, gl_TexCoord[5].xyz, realLightOrigin, $shadowMapInfo[i]);

			finalColor += ( diffuseColor.xyz + specularColor ) * lightColor * shadow;
		}

		gl_FragColor.xyz = diffuseMap.xyz * finalColor;
		gl_FragColor.w = 1.0;
	}
}